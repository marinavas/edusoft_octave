<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Променљиве и операције над њима</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="stylesheet"
      href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
    />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"></script>
    <script src="course.js"></script>
    <link rel="stylesheet" href="course.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  </head>
  <body>
 
  <div class="header">
    <div class = "float-left"> <button class="openbtn" id = "openbar" onclick="openNav()"><i class="fa fa-bars fa-solid"> Отвори садржај</i></button></div>
    
  </div>

  <div id="sidebar" class="sidebar d-none">
    
    
    <ul>
      <li><button class="closebtn d-none"  id="closebar" onclick="closeNav()"><i class="fa fa-bars fa-solid"> Затвори садржај</i></button></li>
      <li><a href="./intro.html">Увод</a></li>
      <li><a class="active" href="./vectors.html">Променљиве и операције</a></li>
      <li><a href="./functions.html">Функције и визуализација</a></li>
      <li><a href="./equations.html">Решавање једначина</a></li>
      <li><a href="./approximations.html">Апроксимације и интерполација</a></li>
      <li><a href="./differential.html">Диференцијални рачун</a></li>
      <li><a href="./fourier.html">Фуријеова трансформација</a></li>
      <li><a href="./statistics.html">Проблеми статистике</a></li>
    </ul>
  </div>
  

  <div id = "main">

    <h3>Основни нумерички типови података</h3>
    <p>Под основним нумеричким типовима података сматрамо скаларе, векторе и матрице. На пример, скаларној променљивој имена <code>a</code> можемо доделити вредност <code>1</code> на следећи начин:
    </p>  
    <pre><code >>> a=1 
a =  1</code></pre>
    <p>У програмском језику Octave није потребно наводити тип података при инстанцирању, као што је случај у програмском језику "C" и другим језицима нижег нивоа.
    Подразумевани тип бројчаних вредности је реалан број.</p>
    
    <p>Вредност променљиве можемо видети куцањем њеног назива у терминалу:</p>
    <pre><code >>> a 
a =  1</code></pre>     

    <p>Низ бројевва можемо задати на следећи начин:</p>
    <pre><code >>> b = [1 2 3] 
b =

   1   2   3</code></pre>

    <p>Овако задати низ програмски језик Octave посматра као једну вектор врсте. Елементи се такође могу задати раздвојени запетом на следећи начин:</p>
  
  <pre><code >>> b = [1, 2, 3] 
b =

    1   2   3</code></pre>

    <p>Уколико желимо да задамо вектор колоне, то можемо урадити на следећи начин:</p>
    <pre><code >>> c = [1; 2; 3] 
c =

    1   
    2   
    3</code></pre>

    <p>Матрицу задајемо навођењем колона реодом раздвојене знаком <code>;</code></p>
    <pre><code >>> A = [1 2 3; 4 5 6; 7 8 9] 
A =

    1   2   3   
    4   5   6   
    7   8   9</code></pre>



<p>У раду са матрицама често су нам потребне матрица која има све нуле, матрица која има све јединице и јединична матрица, односно матрица која има јединице на дијагонали а нула на осталим местима.
  У програмском језику Octave њих можемо добити редом функцијама <code>zeros</code>, <code>ones</code> и <code>eye</code> постављајући као аргументе димензију жељене матрице као у примеру:
</p>
    
<pre><code >>> zeros(2,5)
ans =

    0   0   0   0   0
    0   0   0   0   0

>> ones(4,1)
ans =

    1
    1
    1
    1

>> eye(4)
ans =

Diagonal Matrix

    1   0   0   0
    0   1   0   0
    0   0   1   0
    0   0   0   1</code></pre>

<p>Такође нам је често потребан низ еквидистантних тачака на неком интервалу што можемо добити коришћењем функције <code>linspace</code>:</p>

<pre><code >>> linspace(1,2,5)
ans =

    1.0000   1.2500   1.5000   1.7500   2.0000</code></pre>

<h3>Комплексни бројеви</h3>

<p>У програмском језику Octave подржан је рад са комплексним бројевима. Комплексан број пишемо у облику <code>z = a + bi</code>, где је <code>*</code> реалан део,
а <code>*</code> имагинарни део броја <code>*</code> и <code>*</code> имагинарна јединица. При задавању комплексног броја, за обележавање имагинарне јединице 
могу се користити симболи <code>i</code>, <code>j</code>, <code>I</code> i <code>J</code>, а при испису то ће увек бити <code>i</code> као у примеру:</p>
<pre><code >>> z = 1+2I
z =  1 + 2i</code></pre>

<p>Уколико нас занима реални или имагинарни део броја, то можемо добити редом функцијама <code>real</code> и <code>imag</code>:</p>
<pre><code >>> real(z)
ans =  1
>> imag(z)
ans =  2</code></pre>

<p>На исти начин као матрице реалних бројева задају се матрице комплексних бројева. Уколико је барем један број у матрици комплексан, цела матрица се сматра комплексном.
  Уколико низ задајемо тако што елементе раздвајамо размаком, битно је обратити пажњу да нема размака између реалног и имагинарног дела како они не би били протумачени
  као два одвојена комплексна броја:
</p>

<pre><code >>> Z = [1+2i 3 -4i]
Z =

    1 + 2i   3 + 0i  -0 - 4i</code></pre>

<h3>Приступање и измена елемената</h3>

<p>Да бисмо приступили одређеном елементу вектора врсте, наводимо њен редни број у заградама:</p>

<pre><code >>> b(2)
ans =  2</code></pre>
<p> Приметимо да се, за разлику од неких других програмских језика, индексирање врши од броја <code>1</code>.</p>
<p>На сличан начин приступамо елементима матрице. На пример, елементу у другој врсти и трећој колони матрице <code>А</code> приступамо на следећи начин:</p>

<pre><code >>> A(2,3)
ans =  6</code></pre>

<p>У програмском језику Octave могуће је приступити и делу  матрице, на пример елементи који се налазе у прве две колоне и друге две врсте матрице <code>А</code> добијамо на следећи начин:</p>

<pre><code >>> A(1:2,2:3)
ans =  

    2   3
    5   6
</code></pre>

<p>На сличан начин можемо и мењати вредности елемтима матрице. На пример, уколико желимо да поставимо елемент у другом реду и трећој колони матрице <code>А</code> на <code>-10.1</code> то можемо урадити на следећи начин:</p>

<pre><code >>> A(2,3) = -10.1
A =  
  
    1.0000    2.0000    3.0000
    4.0000    5.0000  -10.1000
    7.0000    8.0000    9.0000 </code></pre>


<p>Када барем један од елемената матрице није цео број, матрица се цела исписује у подешеном формату исписа реалног бројева. Без обзира на начин исписа,
  програмски језик Octave све рачунске операције обавља као да су у питању реални бројеви двоструке прецизности. Подразумеван је скраћени запис реалних бвројева,
  али то се може променити наредбом <code>format long</code>, као и вратити назад на краћи запис наредбом <code>format short</code>
</p>

<p>Осим постављања вредности једном елементу, могуће је поставити вредност одређених елемената матрице на следеће начине:</p>

<pre><code >>> A(1:2,2:3) = 100
A =

    1   100   100
    4   100   100
    7     8     9 
    
>> A(1:2,2:3) = [-2 -3; -5 -6]
A =
  
    1  -2  -3
    4  -5  -6
    7   8   9 

>> A(2,:) = b
A =
  
    1  -2  -3
    1   2   3
    7   8   9</code></pre>


<h3>Рад са низовима</h3>
<p>Брисањем колоне матрице <code>А</code> добијамо матрицу која има 2 колоне и 3 врсте на следећи начин:</p>
<pre><code >>> A(:,2) = []
A =
  
    1  -3
    1   3
    7   9 </code></pre>
<p>Конкатенацију низова вршимо на следећи начин:</p>
<pre><code >>> b = [b 4 5]
b =

    1   2   3   4   5 </code></pre>

<p>Низове можемо индексирати и са одређеним кораком навођењем <code>(почетак : корак : крај)</code>, на пример уколико желимо да добијемо све елементе низа <code>b</code> на непарним позицијама то можемо урадити овако:</p>
<pre><code >>> b(1:2:5)
ans =
  
    1   3   5</code></pre>

<p>Још један начин индексирања низа је низом индекаса:</p>
<pre><code >>> c = [2 4 6 8 10];
>> i = [3 2 1 4];
>> c(i)
ans =

6   4   2   8</code></pre>

<h3>Информације о променљивама</h3>

<p>Листу свих променљивих које су тренутно активне и информације о њима добијамо наредбом <code>whos</code> :</p>

<pre><code >>> whos
Variables in the current scope:

    Attr Name        Size                     Bytes  Class
    ==== ====        ====                     =====  =====
         A           3x2                         48  double
         a           1x1                          8  double
         b           1x5                         40  double
         c           3x1                         24  double

Total is 15 elements using 120 bytes</code></pre>

<p>Уколико желимо да сазнамо димензије једне променљиве, то можемо коришћењем функције <code>size</code>:</p>
<pre><code >>> size(A)
ans =

    3   2</code></pre>

<p>Први број представља број редова, а други број колони, што смо појединачно могли добити редом функцијама <code>rows</code> и <code>columns</code>: </p>
<pre><code >>> rows(A)
ans =  3
>> columns(A)
ans =  2</code></pre>




<h3>Основне операције над променљицама</h3>

<p>Оператор <code>+</code> у програмском језику Octave може се користити на више начина:
<ul> 
    <li>Сабирањем две матрице исте димензије оне се сабирају елемент по елемент. </li>
    <li>Матрица која има <code>n</code> редова и <code>m</code> колона  може се сабирати са векторима димензија <code>nx1</code> и <code>1xm</code>, где се свака од колона, односно редова,
    сабира са датим вектором. 
    <li>Сабирањем вектора димензија <code>nx1</code> и <code>1xm</code> матрицу димензије <code>nxm</code> такву да елемент на позицији <code>(i,j)</code> представља збир одговарајућих елемената првог и другог вектора.</li>
    <li>Произвољна матрица може се сабрати са скаларом, када се сваки од њених елемената сабира са тим скаларом.</li>
    
</ul>
<p>Исто важи за оператор <code>-</code></p>


<pre><code >>> A = [1 2 3; 4 5 6], B = ones(2,3), C = [1 2; 2 1], a = [1 2 3], b = [2;4], c = 5;
>> A+B
ans =

    2   3   4
    5   6   7

>> B+a
ans =

   2   3   4
   2   3   4

>> B-b
ans =

  -1  -1  -1
  -3  -3  -3

>> a+b
ans =

    3   4   5
    5   6   7
    
>> A+c
ans =

    6    7    8
    9   10   11</code></pre>

<p>Оператор <code>*</code> у програмском језику Octave представља матрично множење, као и множење матрице скаларом. Да бисмо могли да их помножимо, матрице морају бити одговарајућих димензија, односно
број колона прве матрице мора одговарати броју редова друге матрице. Множењем матрица димензија <code>nxk</code> и <code>kxm</code> добијамо матрицу димензије <code>nxm</code>. Степеновање квадратне
матрице вршимо оператором <code>^</code> као у примеру</p> 

<pre><code >>> C*A
ans =

    9   12   15
    6    9   12 

>> c*A
ans =

    5   10   15
    20   25   30

>> A*B
error: operator *: nonconformant arguments (op1 is 2x3, op2 is 2x3)

>> C^3
ans =

   13   14
   14   13</code></pre>

<p>Коришћењем симбола <code>.</code> испред операције означавамо да желимо да извршимо операцију елемент по елемент. </p>
<pre><code >>> A.*A
ans =

    1    4    9
    16   25   36

>> A.^2
ans =

    1    4    9
    16   25   36  
  
>> A.^A
ans =

        1       4      27
      256    3125   46656</code></pre>

<p>Конјунгцију комплексне матрица вршимо оператором <code>'</code>. За реалне матрице то одговара транспоновању:</p>
<pre><code >>> A'
ans =

    1   4
    2   5
    3   6

>> [1+2i 1-2i; 2-i 2+i]'
ans =

    1 - 2i   2 + 1i
    1 + 2i   2 - 1i</code></pre>

<h3>Логичке операције</h3>

<p>Логичке операције у програмском језику Octave користимо на сличан начин као у већини програмских језика. Вредност <code>нетачно</code>
означава број <code>0</code> док сви остали бројеви означавају вредност <code>тачно</code>. Као и друге операције, може се применити на низовима и матрицама.
Тада за резултат добијам низ, односно матрицу логичких вредности које одговарају датом изразу рачунато елемент по елемент, као у примерима:</p>

<pre><code >>> A = [1 2 3; 4 5 6];
>> B = [1 1 1; 5 6 7];
>> A <= B
ans =

  1  0  0
  1  1  1
  
>> (A > 4 & A <= B)
ans =

  0  0  0
  0  1  1
</code></pre>

</div>
  </body>
</html>